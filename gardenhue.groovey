/**
* Garden Hue v 3.0 
* by lg. kahn
*
* This SmartApp will turn on if enabled after sunset and run to
* sunrise.. It will change the hue color of your garden hue every xx
* minutes based on a schedule.
*
* Version 1.0: April 28, 2016 - Initial release
*
* Version 2.0: add app name to push messages.
* also dont schedule anything if disabled is set.
* clean up and remove some debugging.
* add run every 5 minute option.
* Turn off all hues when saving app.
*
* Version 2.1:
* Add a switch/virtual switch option, which if selected the enable/disable of the app will follow.
*
* Version 3:
* Add option to control each light separately, so each gets its own color.
* Add Holiday Mode option where you can individually control what colors are enabled.
* Related, Add options to turn on/off each color.
* Add every 1 minute option. Use Sparingly can overload back end Scheduling
* Added better logging, so in notification window you can see current color set. This is in order to help debug for when lights stop responding.
* The latest version of this file can be found at
*
*
* Vesion 3,1 :
* Found bug in code when random was off it had a check xxxx = true instead of xxxx == true so it automatically controlled each light (if you have more than one)
* individually even if you hadn't enabled that setting.
*
* v 4.0 oct 2022 fix requirement to make sure holiday works ( need random on). Turn on random if we have holiday mode on automatically.
* Add fade in and fade out options in seconds.
* Add new options for 10, 15, 30 etc seconds to schedule time. Also if the transitions are ?= schedule time, reset the schedule time to 2 minutes.
* Note fade out only works if you dont separate the fixtures as we need to pause execution for the fade off time, else it would immediately turn off or on again the command
* executes immeately even though the light will take the x numbers of seconds to finish the transtion, and without a pause execution the next turn on would happen
* before the transition time has expired. 
*
* Also be warned some lights do not work well or correctly with the setLevel(level,duration) command for fading. Namely the generic zigbee rgb switch does not,
* but the advanced zigbee rgb bulb does.
*
* v 4.1 missing a line needed in the new code for non random rgbiv color changing mode to work correctly. Also figure how to add fade off with the suspendExecution
* in the separate light fixture and random mode. I added it for all fixtures on once outside the separate fixture loop.
* Also was missing code for the non-holiday, random, separated fixture case.
*
* https://github.com/lgkapps/SmartThingsPublic/gardenhue
*
* lgk v 4.2 add 4 custom color hsv templates. notes range not work so change range of colors 0-100 in intialize, also section titles not showing up in the
* page so add paragraph for titles.
* the custom colors only work in random mode as the non random is ROYGBIV that goes through the rainbow and wouldnt make sense to add a custom color in there.
*
* 4.3 fixed but with random mode and all colors on custom colors not kicking in.. missed one change of the hard coded 16 to maxColors variable.
* v 4.4 slight change to fade off code for separate color for each fixture, random (ie holiday mode) there was an extra fade for each
* fixture that was not removed.. all fixtures should have faded off at the same time instead it did that and then did an extra for each which
* made them not come on with the new color at exactly the same time. (left over code artifact from before fade was implemented).

* v 4.5 multitude of changes.
* 
* 1. removed paragraph lines as hubitat now fixed the section headers to include the text which was previously not coming out on the page.
*
* 2. someone pointed out that color input box was now available since 2.3.x so I added that for the custom 1 -4 colors.
*    and removed the hardcoded hue and saturation fields.. Note if you previously set these you now need to  RESET them
*    using the new color selections boxes.
*
*    also related to this I used the custom level as well as hue and staturation which will override the default level you have set .
*    this may not work perfectly as some lights dont show colors well with low levels, if so let me know and i will remove this code.
     But by using this it will try to do the color exactly has you set it. 
*
*    My default colors took that into consideration and only have colors that work well with a level of close to 100%
*

*/

definition(
name: "Garden Hue",
namespace: "lgkapps",
author: "lgkahn kahn-st@lgk.com",
description: "Change hue color of lights based on schedule sunset to sunrise.",
category: "Convenience",
iconUrl: "http://mail.lgk.com/huetree1.png",
iconX2Url:"http://mail.lgk.com/huetree2.png",
iconX3Url: "http://mail.lgk.com/huetree2.png",
)

import hubitat.helper.ColorUtils
preferences {

	section("Choose hue lights you wish to control?") {
                   
            input "hues", "capability.colorControl", title: "Which Color Changing Bulbs?", multiple:true, required: true
        	input "brightnessLevel", "number", title: "Brightness Level (1-100)?", required:false, defaultValue:100 //Select brightness
	}

	section("Choose cycle time between color changes? ") {
             
            input "cycleTime", "enum", title: "Cycle time?" , options: [
                                "10 seconds",
                                "20 seconds",
                                "30 seconds",
                                "45 seconds",
                                "1 minute",
                                "2 minutes",
                                "5 minutes",
			                	"10 minutes", 
				                "15 minutes", 
				                "30 minutes", 
				                "1 hour", 
				                "3 hours"
			], required: true, defaultValue: "30 minutes"
	}

     section( "Turn Off How Many Hours before Sunrise?") {
         
        input "offset", "enum", title: "Turn Off How many hours before sunrise?",options: ["0", "-1", "-2", "-3", "-4", "-5"],
        required: true, defaultValue: "0"
     }
     
     section( "Enabled/Disabled options?" ) {
             
        input "enabled","bool", title: "Enabled?", required: true, defaultValue: true
        input "enableswitch", "capability.switch", title: "Optional: Do you have a switch/virtual switch which the application enable/disable functionality should follow? If you do not want this feature leave blank.", multiple:false, required: false
        input("fadeOnTime", "enum", title: "Optional time to fade when turning on/setting color?", options: ["Off","5","10","15","20","30"], required: true, defaultValue: "Off")
        input("fadeOffTime", "enum", title: "Optional time to fade when turning off (does work if you separate fixtures)?", options: ["Off","5","10","15","20","30"], required: true, defaultValue: "Off")
         
        input "randomMode","bool", title: "Enable Random Mode?", required: true, defaultValue: false
        input "individualControl","bool", title: "Control Each light Fixture Individually?", required: false, defaultValue: false
     }
    
    section ("Custom Colors - Optional (Enable in Next Section)?") {
        
        input "customColor1", "color", title: "Custom Color 1?", width: 2, required: false, defaultValue: "#750000"
        paragraph ""
        input "customColor2", "color", title: "Custom Color 2?", width: 2, required: false, defaultValue: "#007500"
        paragraph ""
        input "customColor3", "color", title: "Custom Color 3?", width: 2, required: false, defaultValue: "#000075"
          paragraph ""
        input "customColor4", "color", title: "Custom Color 3?", width: 2, required: false, defaultValue: "#750075"

    }
	           
    section ("Custom Colors Enabled - Only used in non random/non ROYGBIV mode") {        
     
        input "custom1Enabled", "bool", title: "Enable Custom Color 1?", required: false, defaultValue: false  
        input "custom2Enabled", "bool", title: "Enable Custom Color 2?", required: false, defaultValue: false  
        input "custom3Enabled", "bool", title: "Enable Custom Color 3?", required: false, defaultValue: false  
        input "custom4Enabled", "bool", title: "Enable Custom Color 4?", required: false, defaultValue: false  
    }   
             
    section ("Colors Enabled?") {
       
        input "holidayMode","bool", title: "Allow Enable/Disable for Each Color/Holiday Mode?", required: false, defaultValue: false

        input "redEnabled", "bool", title: "Enable Red?", required: false, defaultValue: true    
        input "brickRedEnabled", "bool", title: "Enable Brick Red?", required: false, defaultValue: true    
        input "safetyOrangeEnabled", "bool", title: "Enable Safety Orange?", required: false, defaultValue: true    
        input "orangeEnabled", "bool", title: "Enable Orange?", required: false, defaultValue: true    
        input "amberEnabled", "bool", title: "Enable Amber?", required: false, defaultValue: true    
        input "yellowEnabled", "bool", title: "Enable Yellow?", required: false, defaultValue: true    
        input "greenEnabled", "bool", title: "Enable Green?", required: false, defaultValue: true    
        input "turquoiseEnabled", "bool", title: "Enable Turquoise?", required: false, defaultValue: true    
        input "aquaEnabled", "bool", title: "Enable Aqua?", required: false, defaultValue: true    
        input "navyBlueEnabled", "bool", title: "Enable Navy Blue?", required: false, defaultValue: true    
        input "blueEnabled", "bool", title: "Enable Blue?", required: false, defaultValue: true    
        input "indigoEnabled", "bool", title: "Enable Indigo?", required: false, defaultValue: true    
        input "purpleEnabled", "bool", title: "Enable Purple?", required: false, defaultValue: true    
        input "pinkEnabled", "bool", title: "Enable Pink?", required: false, defaultValue: true    
        input "rasberryEnabled", "bool", title: "Enable Rasberry?", required: false, defaultValue: true    
        input "whiteEnabled", "bool", title: "Enable White?", required: false, defaultValue: true 
}

     section( "Notification options?" ) {
         
         
     //   input("recipients", "contact", title: "Send notifications to") {
            //input "sendPushMessage", "enum", title: "Send a push notification?", options: ["Yes", "No"], required: false
            input "sendPushMessage", "capability.notification", title: "Notification Devices: Hubitat PhoneApp or Pushover", multiple: true, required: false
            input("debug", "bool", title: "Enable logging?", required: true, defaultValue: false)
         
           // input "phone1", "phone", title: "Send a Text Message?", required: false
    //}
  }
}
	
int getCycleTimeinSeconds()

{ 
    def ctime = 1800 // default if not found 30 minutes
    if (settings.cycleTime != null)
    {
      switch(settings.cycleTime)
        {
            case "10 seconds":
            ctime = 10
            break;
            
            case "20 seconds":
            ctime = 20
            break;
            
            case "30 seconds":
            ctime = 30
            break;
            
            case "45 seconds":
            ctime = 45
            break;
            
            case "1 minute":
            ctime = 60
            break;
            
            case "2 minutes":
            ctime = 120
            break;
            
            case "5 minutes":
            ctime = 300
            break;
            
            case "10 minutes":
            ctime = 600
            break;
            
            case "15 minutes":
            ctime = 900
            break;
            
            case "30 minutes":
            ctime = 1800
            break;
            
            case "1 hour":
            ctime = 3600
            break;
            
            case "3 hours":
            ctime = 10800
            break;
            
            default:
             ctime = 1800
            break;
            
        }
        // now check for problems in time and if so override
        def time1 = 0
        def time2 = 0
        
        if (settings.fadeOnTime != "Off") time1 = settings.fadeOnTime.toInteger()
        if (settings.fadeOffTime != "Off") time2 = settings.fadeOffTime.toInteger()
        
        if (ctime <= (time1 + time2))
        {
            log.warn "Error in settings, the cycle Time of $settings.cycleTime is less than your total fade times of ${time1 + time2}!"
            log.warn "Overriding cycle time to the default 2 minutes!"
            app.updateSetting("cycleTime", [value:"2 minutes", type:"enum"])
            state.cycleTime = ctime
            ctime = 120
        }
    }
   return ctime      
}           
            
def installed() {
    unsubscribe()
    unschedule()
    
    if (hues)
    {
     TurnOff()
    }
    
    if (settings.enabled == true)
    {
      initialize()
    }  
    
   // do event listening on switch whether enabled or not 
     if ((enableswitch) && (hues))
     {
       subscribe(enableswitch,"switch",EnableSwitchHandler)
     }
}

def updated() {

    unsubscribe()
    unschedule()
    
   if (hues)
    {
     // must always turn off here even if disabled, because this gets called when the switch disables and turns stuff off.
     TurnOffAlways()
     runIn(10,"TurnOffAlways")
    }
    
   if (settings.enabled == true)
    {
      initialize()
    }
    
  // do event listening on switch whether enabled or not 
     if ((enableswitch) && (hues))
     {
       subscribe(enableswitch,"switch",EnableSwitchHandler)
     }
     
  if (hues)
    {
        def currSwitches = hues.currentSwitch    
        def onHues = currSwitches.findAll { switchVal -> switchVal == "on" ? true : false }
        def numberon = onHues.size();
        def onstr = numberon.toString() 
        log.debug "in updated on = $onstr"  
    }
    
    
}

def EnableSwitchHandler(evt)
{
    log.debug "In Switch Handler: Switch changed state to: ${evt.value}"
    if (evt.value == "on")
     {
       log.debug "Enabling App!"
       settings.enabled = true
       updated()
       // updated turns off so need to turn back on when switch tripped.. but also need to renable scheduling.
       TurnOn()
      }
    else
     {
       log.debug "Disabling App!"
       settings.enabled = false
       updated()
     }
}

private def initialize() {
     state.version = "4.3"  
     log.debug(" in initialize() (app version ${state.version} for $app.label with settings: ${settings}")   

    // for holiday. mode to work random must be on so if no turn on.
    if ((settings.holidayMode == true) && (settings.randomMode == false))
    {
        log.debug "Overriding and turning on random mode so holiday mode works correctly!"
        app.updateSetting("randomMode", [value:true, type:"bool"])
    }
    
    unschedule()  
    if(hues) 
    {
        subscribe(hues, "switch.on", changeHandler)    
        subscribe(location, "sunset", SunsetHandler)
        subscribe(location, "sunrise", SunriseHandler)
    
    // uses the run every instead of direct schedule to take load off of fixed times on hub        
    def ct = getCycleTimeinSeconds()
    log.debug "Cycle Time is ${settings.cycleTime}, ($ct)"
      
    switch (ct)
    {      
     case "10":
     schedule("0/10 * * * * ? *", "changeHandler")   
     break;
        
      case "15":
      log.debug "Switching color every 15 seconds." 
      schedule("0/15 * * * * ? *", "changeHandler")  
      break;
        
      case "20":
      log.debug "Switching color every 20 seconds."
      schedule("0/20 * * * * ? *", "changeHandler") 
      break;
        
      case "30":
       log.debug "Switching color every 3 seconds."
       schedule("0/30 * * * * ? *", "changeHandler") 
      break;
        
     case "45":
      log.debug "Switching color every 45 seconds."
      schedule("0/45 * * * * ? *", "changeHandler")  
     break;
       
     case "60":
     log.debug "Switching color every minute."
     schedule("0 */1 * * * ? *","changeHandler")
     break;
     
      case "120":
      log.debug "Switching color every 2 minutes."
      schedule("0 */2 * * * ? *","changeHandler")
      break;
        
     case "300":
     log.debug "Switching color every 5 minutes."
     runEvery5Minutes("changeHandler")
     break;
      
     case "600":
     log.debug "Switching color every 10 minutes."
     runEvery10Minutes("changeHandler")
     break;
    
     case "900":
     log.debug "Switching color every 15 minutes."
     runEvery15Minutes("changeHandler")
     break;
    
     case "1800":
     log.debug "Switching color every 30 minutes."
     runEvery30Minutes("changeHandler")
     break;
    
     case "3600":
     log.debug "Switching color every hour."
     runEvery1Hour("changeHandler")
     break;
    
     case  "10800":
     log.debug "Switching color every 3 hours"
     runEvery3Hours("changeHandler")
     break;
      
     default:
     log.debug "Switching color every 30 minutes."
     runEvery30Minutes("changeHandler")
     break;
     
    }
    
       def colorList1 =  hubitat.helper.ColorUtils.rgbToHSV(hubitat.helper.ColorUtils.hexToRGB(customColor1))
       def colorList2 =  hubitat.helper.ColorUtils.rgbToHSV(hubitat.helper.ColorUtils.hexToRGB(customColor2))
       def colorList3 =  hubitat.helper.ColorUtils.rgbToHSV(hubitat.helper.ColorUtils.hexToRGB(customColor3))
       def colorList4 =  hubitat.helper.ColorUtils.rgbToHSV(hubitat.helper.ColorUtils.hexToRGB(customColor4))
             
          log.debug "Custom Color 1 - ${colorList1}"  
          log.debug "Custom Color 2 - ${colorList2}" 
          log.debug "Custom Color 3 - ${colorList3}" 
          log.debug "Custom Colot 4 - ${colorList4}" 
        
        state.custom1Hue = colorList1.get(0)
        state.custom1Saturation = colorList1.get(1)
        state.custom1Level = colorList1.get(2)
        state.custom2Hue = colorList2.get(0)
        state.custom2Saturation = colorList2.get(1)
        state.custom2Level = colorList2.get(2)
        state.custom3Hue = colorList3.get(0)
        state.custom3Saturation = colorList3.get(1)
        state.custom3Level = colorList3.get(2)
        state.custom4Hue = colorList4.get(0)
        state.custom4Saturation = colorList4.get(1) 
        state.custom4Level = colorList4.get(2)
       
  
    subscribe(app,changeHandler)
    
    state.nextOnTime = 0
    state.nextOffTime = 0

   // subscribe(location, "sunsetTime", scheduleNextSunset)
   // sunset handled automaticall need next sunrise to handle offset
    subscribe(location, "sunriseTime", scheduleNextSunrise)
    scheduleNextSunrise()
    // rather than schedule a cron entry, fire a status update a little bit in the future recursively
   // scheduleNext()
    state.currentColor = "None"
    
    }
}

def SunriseHandler(evt)
{
 TurnOff()
 scheduleNextSunrise()
}
 
def SunsetHandler(evt)
{
 TurnOn()
 scheduleNextSunrise()
 }
 
def TurnOffAgain()
{
    hues.off()
}

def TurnOff()
{
    if (debug) log.debug "In turn off"
   if (settings.enabled == true)
    {
        def appLabel = app.getLabel()
        mysend("$appLabel: Turning Off!")
	}
	hues.off()
    // incase light was in a cycle of dimming or brightening the turn off can be ignored schedule again in case
    runIn(30,"TurnOffAgain")
    
}    

def TurnOffAlways()
{
      def appLabel = app.getLabel()
      mysend("$appLabel: Turning Off!")
	  hues.off()
      // incase light was in a cycle of dimming or brightening the turn off can be ignored schedule again in case
      runIn(30,"TurnOffAgain") 
}    

def TurnOn()
{
   if (debug) log.debug "In turn on"
    if (settings.enabled == true)
    {
     def appLabel = app.getLabel()
     mysend("$appLabel: Turning On!")
     hues.on()
    }
}

def scheduleNextSunrise(evt) {

   log.debug "In schedule next sunrise"

    def int sunriseoffset = settings.offset.toInteger()
    log.debug "got sunrise offset = $sunriseoffset"

    // get sunrise and sunset times
    def sunRiseSet = getSunriseAndSunset()
    def sunriseTime = sunRiseSet.sunrise
    def sunsetTime = sunRiseSet.sunset
        
    log.debug "sunrise time ${sunriseTime}"
    log.debug "sunset time ${sunsetTime}"
    
    //get the Date value for the string
    //def sunriseTime = Date.parse("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", sunriseTime)

    // sunrise returns today so double check we are not getting todays time but tomarrow
    // if we are before sunset time we are too early
    
    // bug in get sunrise time somethigs shows todays even though we are passed it.. sometimes
    // shows the next one.. Think it has to do with timezone offset.. so compare to local time to see
    // which case we have and if we need to add 24 hours or not
    
     def currentTime = new Date(now())
     //log.debug "current time = $currentTime, sunrisetime = $sunriseTime, sunsettime = $sunsetTime"
     
     // if current time is greater than sunsirse we are today no tomorrow so add 24 hours.
     if(currentTime.time > sunriseTime.time) {
        log.debug "Adding a day as sunrise time is still today!"
        sunriseTime = new Date(sunriseTime.time + (24 * 60 * 60 * 1000))
    }
   
    //calculate the offset
    def timeBeforeSunrise = new Date(sunriseTime.time + (sunriseoffset * 60 * 60 * 1000))
    log.debug "Scheduling for: $timeBeforeSunrise (sunrise is $sunriseTime)"

    //schedule this to run one time
    if (state.nextOffTime != timeBeforeSunrise)
    {
      log.debug "Scheduling it!"
      runOnce(timeBeforeSunrise, TurnOff)
      state.nextOffTime = timeBeforeSunrise
    }
}

def changeHandler(evt) {

	//log.debug "in change handler"
  	// only do stuff if either switch is on (turns off at sunrise) or turned on manually
    if (hues)
    {
    	 def currSwitches = hues.currentSwitch
         def onHues = currSwitches.findAll { switchVal -> switchVal == "on" ? true : false }
         def numberon = onHues.size();
         def onstr = numberon.toString() 
         
       if ((debug) && (settings.enabled == true)) log.debug "found $onstr that were on!"
      // log.debug "holiday mode = $settings.holidayMode"
       // log.debug "Random mode = $settings.randomMode"
    
    if ((numberon > 0) && (settings.enabled == true))
    {
      def newColor = ""
      if (settings.randomMode == true)
       {

       // lgk define alternate color array if holiday mode enabled
       if (settings.holidayMode == true)
         {
            if (debug) log.debug "Holiday Mode = On, getting count of colors Enabled."
            
         // now define new array
         def enabledColorArray = []

           if (redEnabled == true)
               enabledColorArray <<  "Red"
           if (brickRedEnabled == true)
               enabledColorArray <<  "Brick Red"
           if (safetyOrangeEnabled == true)
               enabledColorArray <<  "Safety Orange"
           if (orangeEnabled == true)
               enabledColorArray <<  "Orange"
           if (amberEnabled == true)
               enabledColorArray <<  "Amber"
           if (yellowEnabled == true)
               enabledColorArray <<  "Yellow"
           if (greenEnabled == true)
               enabledColorArray <<  "Green"
           if (turquoiseEnabled == true)
               enabledColorArray <<  "Turquoise"
           if (aquaEnabled == true)
               enabledColorArray <<  "Aqua"
           if (navyBlueEnabled == true)
               enabledColorArray <<  "Navy Blue"
           if (blueEnabled == true)
               enabledColorArray <<  "Blue"
           if (indigoEnabled == true)
               enabledColorArray <<  "Indigo"
           if (purpleEnabled == true)
               enabledColorArray <<  "Purple"
           if (pinkEnabled == true)
               enabledColorArray <<  "Pink"
           if (rasberryEnabled == true)
               enabledColorArray <<  "Rasberry"
           if (whiteEnabled == true)
               enabledColorArray <<  "White"
           if (custom1Enabled == true)
               enabledColorArray << "Custom1"
           if (custom2Enabled == true)
               enabledColorArray << "Custom2"
           if (custom3Enabled == true)
               enabledColorArray << "Custom3"
           if (custom4Enabled == true)
               enabledColorArray << "Custom4"
            
           def int colorsEnabled = enabledColorArray.size
           if (debug) log.debug "Enabled Color Count = $colorsEnabled"
           if (debug) log.debug "Enabled Color Array = $enabledColorArray"

           if ((numberon > 1) && (settings.individualControl == true))
             {

                 // this needs to be done here outside the loop and not in the individual fixture loop becuase of the pauseExecution otherwise fixtures
                 // will be out of sync.
                 if (settings.fadeOffTime != "Off")
                   {                  
                       def fOffTime = settings.fadeOffTime.toInteger() 
                       if (debug) log.debug "Fading off in $fOffTime seconds before changing color."
                       hues*.setLevel(1,fOffTime)
                       pauseExecution(fOffTime*1000) 
                   }
                            
                 for (def i=0; i<numberon; i++) 
                      {
                            def int nextValue = new Random().nextInt(colorsEnabled)
                            if (debug) log.debug "Colors Enabled: $colorsEnabled, Hue: $i, Random Number = $nextValue"
                            newColor = enabledColorArray[nextValue]

                            log.debug("$app.label: Hue:$i - Setting Color to $newColor.")                         
                            sendcolor(newColor,i)
                     }
             } // do each individually
        
           else
               {

                def int nextValue = new Random().nextInt(colorsEnabled)
                if (debug) log.debug "Colors Enabled: $colorsEnabled, Random Number = $nextValue"
                newColor = enabledColorArray[nextValue]

                log.debug("$app.label: Setting Color to $newColor.")
                //hues.on()
                sendcolor(newColor)

              }

       } // holiday mode on


     else {
        // not holiday mode but random
              
          if ((numberon > 1) && (settings.individualControl == true))
             {
                 if (debug) log.debug "Non Holiday, Random, Separated case"
                 // this needs to be done here outside the loop and not in the individual fixture loop becuase of the pauseExecution otherwise fixtures
                 // will be out of sync.
                 if (settings.fadeOffTime != "Off")
                   {                  
                       def fOffTime = settings.fadeOffTime.toInteger() 
                       if (debug) log.debug "Fading off in $fOffTime seconds before changing color."
                       hues*.setLevel(1,fOffTime)
                       pauseExecution(fOffTime*1000) 
                   }
                            
                 for (def i=0; i<numberon; i++) 
                      {
                          def maxColors = 16
                          def colorArray = ["Red","Brick Red","Safety Orange","Orange","Amber","Yellow","Green","Turquoise","Aqua","Navy Blue","Blue","Indigo","Purple","Pink","Rasberry","White"]
                        
                          if (custom1Enabled == true)
                            {
                              ++maxColors
                              colorArray[maxColors-1] = "Custom1"
                              if(debug) log.debug "color array = $colorArray, maxColors = $maxColors"
                            }
                              
                          if (custom2Enabled == true)
                            {
                              ++maxColors
                              colorArray[maxColors-1] = "Custom2"
                              if (debug) log.debug "color array = $colorArray, maxColors = $maxColors"
                            }
                          
                         if (custom3Enabled == true)
                           {
                              ++maxColors
                              colorArray[maxColors-1] = "Custom3"
                              if (debug) log.debug "color array = $colorArray, maxColors = $maxColors"
                           }
                          
                         if (custom4Enabled == true)
                           {
                              ++maxColors
                              colorArray[maxColors-1] = "Custom4"
                              if (debug) log.debug "color arrary = $colorArray, maxColors = $maxColors"
                           }
                          
                     
                           def int nextValue = new Random().nextInt(maxColors)
                           if (debug) log.debug "Hue: $i, Random Number = $nextValue"
                            newColor = colorArray[nextValue]
                            log.debug("$app.label: Hue:$i - Setting Color to $newColor.")                         
                            sendcolor(newColor,i)
                     }
             } // do each individually
          else
          { 
           def colorArray = ["Red","Brick Red","Safety Orange","Orange","Amber","Yellow","Green","Turquoise","Aqua","Navy Blue","Blue","Indigo","Purple","Pink","Rasberry","White"]
           def maxColors = 16
           
 
           if (custom1Enabled == true)
             {
               ++maxColors
               colorArray[maxColors-1] = "Custom1"
               if (debug) log.debug "color array = $colorArray, maxColors = $maxColors"
             }
                              
           if (custom2Enabled == true)
              {
                ++maxColors
                colorArray[maxColors-1] = "Custom2"
                if (debug) log.debug "color array = $colorArray, maxColors = $maxColors"
              }
                          
            if (custom3Enabled == true)
              {
                ++maxColors
                colorArray[maxColors-1] = "Custom3"
                if (debug) log.debug "color array = $colorArray, maxColors = $maxColors"
              }
                          
            if (custom4Enabled == true)
              {
               ++maxColors
               colorArray[maxColors-1] = "Custom4"
               if (debug) log.debug "color arrary = $colorArray, maxColors = $maxColors"
              }            
              
           if (debug) log.debug "Holiday mode is not on."
           def int nextValue = new Random().nextInt(maxColors)
         
           if (debug) log.debug "Random Number = $nextValue"
           newColor = colorArray[nextValue]    

            log.debug("$app.label: Setting Color to $newColor.")
            //hues.on()
             sendcolor(newColor)
  
          } 
        }

       }
       
      else
      
      { // not random
        // note custom colors not used in raindbow ie not random mode.2
       def currentColor = state.currentColor
       if (debug) log.debug " in changeHandler non-random case, got current color = $currentColor"

       switch(currentColor) {
    
		case "Red":
			newColor="Brick Red"
			break;
		case "Brick Red":
			newColor = "Safety Orange"
			break;
		case "Safety Orange":
			newColor = "Orange"
			break;
		case "Orange":
			newColor = "Amber"
			break;
		case "Amber":
			newColor = "Yellow"
			break;
		case "Yellow":
			newColor = "Green"
			break;
		case "Green":
			newColor = "Turquoise"
			break;
        case "Turquoise":
			newColor = "Aqua"
			break;
		case "Aqua":
			newColor = "Navy Blue"
			break;
        case "Navy Blue":
			newColor = "Blue"
			break;
		case "Blue":
			newColor = "Indigo"
			break;
		case "Indigo":
			newColor = "Purple"
			break;
        case "Purple":
			newColor = "Pink"
			break;
        case "Pink":
			newColor = "Rasberry"
			break;
        case "Rasberry":
			newColor = "White"
			break;
        case "White":
			newColor = "Red"
			break;  
         default:
        	log.debug "in default"
            newColor = "Red"
			break;
	}

      log.debug "After Check new color = $newColor"
      //hues.on()
      sendcolor(newColor)

    } // end random or not
    
      }
   }
}


def sendcolor(color) { 
    //log.debug "In send color"
	//Initialize the hue and saturation
	def hueColor = 0
	def saturation = 100

	//Use the user specified brightness level. If they exceeded the min or max values, overwrite the brightness with the actual min/max
	if (brightnessLevel<1) {
		brightnessLevel=1
	}
    else if (brightnessLevel>100) {
		brightnessLevel=100
	}
   
    blevel = brightnessLevel
	//Set the hue and saturation for the specified color.
	switch(color) {
		case "White":
			hueColor = 0
			saturation = 0
			break;
		case "Daylight":
			hueColor = 53
			saturation = 91
			break;
		case "Soft White":
			hueColor = 23
			saturation = 56
			break;
		case "Warm White":
			hueColor = 20
			saturation = 80 
			break;
        case "Navy Blue":
            hueColor = 61
            break;
		case "Blue":
			hueColor = 65
			break;
		case "Green":
			hueColor = 35
			break;
        case "Turquoise":
        	hueColor = 47
            break;
        case "Aqua":
            hueColor = 50
            break;
        case "Amber":
            hueColor = 13
            break;
		case "Yellow":
			//hueColor = 25
            hueColor = 17
			break; 
        case "Safety Orange":
            hueColor = 7
            break;
		case "Orange":
			hueColor = 10
			break;
        case "Indigo":
            hueColor = 73
            break;
		case "Purple":
			hueColor = 82
			saturation = 100
			break;
		case "Pink":
			hueColor = 90.78
			saturation = 67.84
			break;
        case "Rasberry":
            hueColor = 94
            break;
		case "Red":
			hueColor = 0
			break;
        case "Brick Red":
            hueColor = 4
            break; 
        case "Custom1":
            hueColor = state.custom1Hue
            saturation = state.custom1Saturation
            blevel = state.custom1Level
            break;
        case "Custom2":
            hueColor = state.custom2Hue
            saturation = state.custom2Saturation
            blevel = state.custom2Level
            break;
        case "Custom3":
            hueColor = state.custom3Hue
            saturation = state.custom3Saturation
            blevel = state.custom3Level
            break;
        case "Custom4":
            hueColor = state.custom4Hue
            saturation = state.custom4Saturation
            blevel = state.custom4Level
            break;
	}

	//Change the color of the light
    
    if (blevel == null)
    {
        log.warn "Error: brlighnes level was 0 reseting to 100"
        blevel = 100
    }
    
    if (settings.fadeOnTime == "Off")
    {       
       if (settings.fadeOffTime != "Off")
        {
           // case with only fade off.. 
           def fOffTime = settings.fadeOffTime.toInteger() 
           if (debug) log.debug "Fading off in $fOffTime seconds before changing color."
           hues*.setLevel(1,fOffTime)
           pauseExecution(fOffTime*1000) 
        }
            
	     def newValue = [hue: hueColor, saturation: saturation, level: blevel]  
	     hues*.setColor(newValue)
         state.currentColor = color
         mysend("$app.label: Setting Color = $color")
         if (debug) log.debug "$app.label: Setting Color = $color"
    }
    else
    {
      if (settings.fadeOffTime != "Off")
        {
         
            // fade out first before changing color if enabled
            def fOffTime = settings.fadeOffTime.toInteger() 
            if (debug) log.debug "Fading off in $fOffTime seconds before changing color."
            hues*.setLevel(1,fOffTime)
            pauseExecution(fOffTime*1000)
        }
       else
       {
        if (settings.fadeOnTime != "Off") hues*.setLevel(1,0)   
       }
        
        // now turn on at level 1 and fade up
        def fOnTime = settings.fadeOnTime.toInteger()
        if (debug) log.debug "Turning on at level 1, then fading up to $blevel in $fOnTime seconds."
        if (debug) log.debug "new hue: $hueColor, new staturation: $saturation, new Level: $blevel"
        def newValue = [hue: hueColor, saturation: saturation, level: 1] 
        
        state.currentColor = color
	    hues*.setColor(newValue)
        hues*.setLevel(blevel,fOnTime)
    }

}

def sendcolor(color,which)
{
     if (debug) log.debug "In send color for hue $which"
	//Initialize the hue and saturation
	def hueColor = 0
	def saturation = 100

	//Use the user specified brightness level. If they exceeded the min or max values, overwrite the brightness with the actual min/max
	if (brightnessLevel<1) {
		brightnessLevel=1
	}
    else if (brightnessLevel>100) {
		brightnessLevel=100
	}
    
    blevel = brightnessLevel
    
	//Set the hue and saturation for the specified color.
	switch(color) {
		case "White":
			hueColor = 0
			saturation = 0
			break;
		case "Daylight":
			hueColor = 53
			saturation = 91
			break;
		case "Soft White":
			hueColor = 23
			saturation = 56
			break;
		case "Warm White":
			hueColor = 20
			saturation = 80 
			break;
        case "Navy Blue":
            hueColor = 61
            break;
		case "Blue":
			hueColor = 65
			break;
		case "Green":
			hueColor = 33
			break;
        case "Turquoise":
        	hueColor = 47
            break;
        case "Aqua":
            hueColor = 50
            break;
        case "Amber":
            hueColor = 13
            break;
		case "Yellow":
			//hueColor = 25
            hueColor = 17
			break; 
        case "Safety Orange":
            hueColor = 7
            break;
		case "Orange":
			hueColor = 10
			break;
        case "Indigo":
            hueColor = 73
            break;
		case "Purple":
			hueColor = 82
			saturation = 100
			break;
		case "Pink":
			hueColor = 90.78
			saturation = 67.84
			break;
        case "Rasberry":
            hueColor = 94
            break;
		case "Red":
			hueColor = 0
			break;
        case "Brick Red":
            hueColor = 4
            break;
        case "Custom1":
            hueColor = state.custom1Hue
            saturation = state.custom1Saturation
            blevel = state.custom1Level
            break;
        case "Custom2":
            hueColor = state.custom2Hue
            saturation = state.custom2Saturation
            blevel = state.custom2Level
            break;
        case "Custom3":
            hueColor = state.custom3Hue
            saturation = state.custom3Saturation
            blevel = state.custom3Level
            break;
        case "Custom4":
            hueColor = state.custom4Hue
            saturation = state.custom4Saturation
            blevel = state.custom4Level
            break;
    }
    
   if (blevel == null)
    {
        log.warn "Error: brlighnes level was 0 reseting to 100"
        blevel = 100
    }
    
   if (settings.fadeOnTime == "Off")
    {
    
	//Change the color of the light
	def newValue = [hue: hueColor, saturation: saturation, level: blevel]  
	hues[which].setColor(newValue)
    state.currentColor = color
    mysend("$app.label: hue: $which, Setting Color = $color")
    log.debug "$app.label: hue: $which Setting Color = $color"
    }
    
    else
    {
        
        //cannot do fade off here as we need to pause execution for the fade off time before turning back on the other color and with each fixture being separate 
        // this is done prior to the call for all fixtures if necessary not here in the looop
        
       // if (settings.fadeOnTime != "Off") hues[which].setLevel(1,0)   
        // now turn on at level 1 and fade up
        def fOnTime = settings.fadeOnTime.toInteger()
        if (debug) log.debug "Turning fixture $which on at level 1, then fading up to $blevel in $fOnTime seconds."
        if (debug) log.debug "new hue: $hueColor, new staturation: $saturation, new Level: $blevel"
        def newValue = [hue: hueColor, saturation: saturation, level: 1]  
	    hues[which].setColor(newValue)
        hues[which].setLevel(blevel,fOnTime)
    }
        
}

private mysend(msg) {
    
     // check that contact book is enabled and recipients selected
    if (location.contactBookEnabled && recipients) {
        if (debug) log.debug("sending notifications to: ${recipients?.size()}")
        sendNotificationToContacts(msg, recipients)
    } else {
        if (sendPushMessage) {
            if (debug) log.debug("Sending Push Notification...")
         
            sendPushMessage.deviceNotification(msg)
        } 
        
    }
}

